## 第二章
### 1.JVM 中内存的划分
#### 1.程序计数器
程序计数器这部分内存是线程私有的用于记录线程执行的字节码地址, 这块区域没有定义任何异常
#### 2.Java虚拟机栈
虚拟机栈这部分内存也是线程私有的用于存储局部变量 操作数栈 动态链接 方法出口 一个方法执行完里面的局部变量就出栈了
如果超过了最大的栈深度就会抛出Stack Overflow异常 如果无法申请到足够的内存就抛出OutOfMemory异常
#### 3.本地方法栈
用途跟虚拟机栈相同但是用于native 代码 抛出异常和虚拟机栈相同
#### 4.Java堆内存
Java堆内存用于存放对象实例和数组,粗略的划分可以分成新时代和老年代,进一步划分可以划分为Eden空间,From Sourvivor空间,To Sourvivor空间,在对象内存未分配完成并且内存无法拓展的情况下会抛出OutOfMemoryError
#### 5.方法区
内存方法区用于存储 已经加载的了类信息 常量 静态变量 及时编译器编译后的数据,会抛出OutOfMemoryError
#### 6.运行时常量池
这部分内存归属于方法区,用于存放各种字面量和符号引用,和方法区一样会抛出OutOfMemoryError
#### 7.直接内存
不是运行时数据区的一部分但是频繁的调用可能会抛出OutOfMemoryError,大小受到本机内存的限制
### 2.JVM中对象的创建过程
#### 创建过程
1.类加载
2.为新生对象分配内存
3.将分配到的内存初始化为全0
4.设置初始化信息
    设置头信息
    - 那个类的实例
    - 如何找到类的元数据信息
    - 对象的hash码
    - 对象的GC分代年龄
5.执行构造方法
##### 内存分配的算法
###### 指针碰撞
内存规整,用过的内存放在一边,没有用过的放在另一边中间放一个指针作为分界点指示器,分配内存时将指针向空闲区域移动内存大小的距离
###### 空闲列表
虚拟机维护一个列表记录哪些内存是可用的,分配内存时找到大于所需内存的内存块进行分配
没有回答的问题:找到第一块还是找到大小最接近的一块内存
##### 解决多线程分配的算法
###### CAS配上失败重试
1.CAS 只能有一个线程成功,其他线程重试直至成功分配
###### 为每个线程分配TLAB本地线程分配缓冲
将每个线程的内存分开来,在用完需要重新分配的时候才需要同步是否使用TALB通过-XX:-UseTLAB 参数控制,默认不使用
#### 对象内存布局
##### 1.对象头 存储运行时数据
###### 第一部分 运行时数据
- hash码
- GC分代年龄
- 锁状态标志
- 线程持有锁
- 偏向线程ID
- 偏向时间戳
在32位和64位虚拟机中长度分别为 32位 和64位
在状态不同的情况下存储的信息意义也不相同
###### 类型指针
- 指向类元数据,表示这个对象属于哪个类
- 不一定指向类,如果对象是一个数组,那么必须要有一块内存记录长度
可以通过类型元数据确定对象的大小,但是无法确定数组长度(确定最多有多少个对象,但是无法确定现在存了多少个)
##### 2.实例数据
定义的域 的数据
内存分配策略 从长到短
在满足这个条件的情况下 父类定义的变量会出现在子类变量之前,如果 CompactFields参数值为true(默认),那么子类比较窄的变量可能会插入到父类变量空隙之中
##### 3.对其填充
如果实例部分内存不是8字节的整数倍那么通过对齐补全
#### 内存访问策略
##### 内存句柄访问
专门分配一个内存区域用于存放内存句柄 优点是:对象中存储的引用地址不变化
##### 内存指针直接访问
对象中引用变量直接存储对象地址 优点是:只需要一次指针定位
### 3.如何让内存抛出内存溢出异常
#### Java堆内存溢出
1. 不断创建对象
2. 持有对象不释放
#### 虚拟机栈和本地方法栈溢出
递归调用直到内存不够,栈深度超出限制

## 第三章
内存回收的关注区域在与Java堆和方法区
### 垃圾标记算法
#### 1.引用计数算法
描述:每当有一个地方引用对象时计数器加1,当引用失效时计数器减1,如果计数是0了那么表示该对象需要回收
- 优点:实现简单,判断效率高
- 缺点:无法解决对象之间的循环引用问题
#### 2.可达性分析算法
通过一系列的称为"GC Roots"对象作为起点向下搜索所走过的路径为引用链当一个对象到任何Roots 都不可达时就判定可回收
##### 可以作为GC Roots 的对象
- 虚拟机栈引用的对象
- 方法区中静态属性引用对象
- 方法区常量引用对象
- 本地方法JNI引用对象
#### 四种类型的引用
##### 1.强引用
##### 2.软引用
##### 3.弱引用
##### 4.虚引用
#### 方法区(永久代)的回收
- String 其他类(接口) 方法 字段 符号引用 不再引用那么可能被清除出内存
##### 无用类判定
- 类所有实例被回收
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class 对象没有任何地方被引用

### 3.回收算法
#### 标记-清除算法
描述:首先标记出所有需要回收的对象,在标记之后统一回收
##### 缺点
- 效率问题,标记清除两个过程的效率都不高
- 空间问题,标记清除之后产生大量的不连续碎片
#### 复制算法
将内存划分为两块,一块内存使用完了,那么将还存活的内存复制到下一块区域,将使用过得内存一次清理掉
##### 优点
- 没有碎片问题
- 实现简单,运行高效
##### 缺点
- 内存缩小了原来的一半

用于回收新生代
#### 标记-整理算法
复制算法因为缺陷一般不用于老年代的回收

算法描述:回收对象的时候将还存活的对象向一端移动,将后面的内存直接清理
##### 优点
- 可以避免在存活100% 的时候进行复制在老年代存活率比较高的情况下使用
#### OopMap
这个结构记录了再什么偏移量上是什么引用类型的数据
#### 安全点
特定的位置记录了OopMap,这些位置称之为安全点
##### 安全点的选定规则
以程序是否具有让程序长时间执行的特征,"长时间运行"的最明显特征就是指令序列的复用,例如方法调用\循环跳转\异常跳转,具有这些功能指令的地方会产生安全点
#### 安全区域
### 4.具体的垃圾收集器
#### serial
STW 回收,执行垃圾回收的时候停止所有的线程,单线程回收,采用复制算法
##### 优点
简单高效

对于client模式下的虚拟机来说是一个好的选择
#### ParNew
serial 虚拟机的多线程版本
#### 特点
- 控制参数,收集算法,Stop The World 对象分配规则 回收策略都和serial相同,只是在回收的时候使用多线程进行回收
- 是server模式下默认的收集器
- 是唯一能和CMS搭配使用的收集器

#### Parallel Scavenge
新生代收集器,使用复制算法
##### 设计目的
为了控制吞吐量
可以定制优化目标收集器会自动优化
#### Seriel Old
采用标记整理算法
#### CMS
##### 设计目的
获取短回收停顿时间
##### 回收算法
标记清理回收算法
##### 步骤
- 初始标记 STW

标记GC Root 直接关联对象
- 并发标记

进行GC Root 追溯,标记所有可达对象
- 重新标记 STW

在并发标记期间发生变化的对象
- 并发清除
##### 缺点
- 对于cpu资源比较敏感
CMS默认启动的回收线程数(cpu数 + 3)/4
- 无法处理浮动垃圾
在标记过程之后产生的垃圾称之为浮动垃圾
- 标记清除后产生大量的碎片
如果无法找到足够大的内存空间,那么就会触发一次Full GC
#### G1
##### 设计用途
面向服务端应用的垃圾收集器
##### 回收算法
标记-清理算法
##### 优点
- 并行并发
- 分代收集
- 空间整合
- 可预测停顿
##### G1收集器的内存划分
G1收集器将内存划分为到校相等的独立区块(Region),新生代和老年代不再是物理隔离而是,独立区块的集合,能够实现时间预测是因为能够避免进行全区域的内存回收,G1 会跟踪各个独立区块的价值大小(可回收空间大小和所需时间),维护一个优先列表,在允许时间内回收价值最大的区域
##### 当引用对象在另外的独立区块时如何避免全堆扫描
G1 中每个Region 中都有对应的Remembered Set ,程序在发现对Ref对象进行写操作时,会产生一个Write Barrier 中断写操作,检查引用对象是不是在不同的Region 中,如果是就通过CardTable 把引用相关信息记录到被引用对象所属的Region的Remembered Set 中
##### 回收过程
- 初始标记
- 并发标记
- 最终标记
- 筛选清除

### 内存分配回收策略
- 优先在Edge内存空间分配,如果没有足够空间那么触发一次GC
#### 大对象
典型的大对象是 很长的字符串和数组,大对象是直接进入老年代的,这是为了避免两个Survivor之间大量内存复制,
#### 长期存活对象
##### 什么是长期存活的对象
对象在Survivor 中没熬过一次Minor GC 年龄就增加一,到了年龄达到一定的年纪(默认是15)之后,会晋升到老年代
#### 动态对象的年龄
虚拟机并不是永远要求必须达到MaxTenuringThreshold才能晋升老年代,如果在survivor空间中相同年纪的所有对象的总和大于Survivor空间的一半,年龄大于等于这一年龄的对象直接进入老年代
#### 空间分配担保
在进行minor GC 之前,虚拟机检查老年代的可用空间是否大于新生代存活对象总空间,如果成立那么这一次的Minor GC 确保是安全的,如果不成立那么需要检查虚拟机是否允许担保失败.如果允许,那么检查一下老年代中的最大连续空间是否大于历次晋升老年代对象的平均大小,如果大于则尝试进行minor GC 如果大于或者不允许冒险 则尽心Full GC
# 程序员修炼之道
## 注重时效的哲学
### 我的源码让猫吃了
1.what
- 这个隐喻是什么意思？ 我的源码被猫吃了是一个极其蹩脚的借口，是对于自己不负责任的行为。
- 隐喻带给我的启示？ 要诚实面对自己的错误和缺点，并设法提供各种选择（解决方案），不要找各种蹩脚的借口，为自己的行为负责。不要说什么做不到，要说明能够做什么来挽救，不要害怕提出要求也不要害怕承认自己需要帮助。
2.how
- 怎么对自己负责？ 要为自己和自己的行为负责，对自己的职业生涯负责，不要害怕承认自己的无知或错误。无知和错误是肯定会发生的。我们对于自己的能力感到自豪，但是对与自己的无知和错误必须要诚实。
- 如何承担责任？ 责任是主动承担的，在承担责任之前可以对责任进行评估决定要不要去承担。如果承诺为某件事情负责，那就负起责任，当出现错误的时候诚实的承认他，并设法给出各种选择（提供解决方案），而不是找各种借口。
- 在可能出现问题前，预先想到并提供解决方案。

### 软件的熵
- 软件的熵是什么？ 软件的熵是软件的无序程度。
- 熵有什么影响？ 当软件的熵增长时，程序员称之为“软件腐烂”。
- 什么造成了软件腐烂？ 软件腐烂最重要的原因之一似乎是开发时心理或文化的变化。
- 什么加速了软件腐烂？ 破窗户效应会加速软件的腐烂。
- 如何对待破窗户？ 不要留着“破窗户”（低劣的设计，错误的决策，糟糕的代码）不修，发现一个修一个,如果没时间修复那么就先用木板订起来 1.可以把出问题的代码放入注释 2.显示未实现 3.使用虚拟的数据
- 人面对不同的软件时候的态度？ 1.如果在破窗户项目中工作，会很容易产生这样的想法：这项目其他部分都是垃圾，我只需要照着做就好了。2.如果所在的团队和项目代码十分漂亮，编写整洁，设计良好，并且很优雅--你会格外注意不把他弄脏，你不想成为第一个弄脏代码的人
### 石头汤煮青蛙
- 石头汤的故事隐喻是什么？ 士兵充当催化剂，让村民做出改变，最后的结果每个人都是赢家
- 石头汤对于我的启发？ 让自己充当催化剂让团队成员做出改变最后得到一个好结果，首先需要做出石头，然后漫不经心的说怎么做会更好，要做改变的催化剂。
- 温水煮青蛙的故事隐喻是什么？ 青蛙没有觉察到环境的变化，也就想程序员没有注意到软件熵的增加。
- 温水煮青蛙的故事的启发？ 要留心大图景不要只关注自己做的部分，留心周围熵值得变化。
- 如何知道自己催化的改变是错误的还是正确的？ （有待解决）
### 足够好的软件
- 什么样的软件是足够好的软件？ 首先软件必须要满足用户的需求，其次得让用户参与来判断这个软件是不是已经足够好了。
- 有什么建议？ 1.所制作的系统的范围和质量应该作为系统需求的一部分规定下来使质量问题变成需求问题。2.尽快提供可用系统，反馈会给你更好的最终解决方案
- 怎么知道什么时候止步？ 不要因为过度的修饰或过于求精而损坏完好的程序，继续前进让你的代码凭借自己的质量站一会。
### 你的知识资产
- 如何估算自己的知识资产？ 并未找到相关答案
- 如何管理知识资产？ 
    1. 定期投资 （投资什么东西尚未解决）
    2. 多元化 知道不同的事情越多，越有价值。掌握技术越多你就越能更好的进行调整，赶上变化。
    3. 管理风险 高风险高收益 新技术 可能立马失去，但是如果技术广泛应用那么收益颇丰。
    4. 低买高卖 新技术，高出现可能比较没有价值，但是如果发展起来，那么价值水涨船高
    5. 及时的重新评估和平衡
- 如何进行投资（如何选择有价值的进行投资）？
- 投资达到的目标
    1. 每年至少学一门语言，学习不同的方法解决相同问题，拓展思维不要墨守成规
    2. 每季度阅读一本技术书籍。
    3. 也要阅读非技术书籍，因为最终沟通的是人，不只要学会和电脑沟通。
    4. 上课，在本地学校查找感兴趣的课
    5. 参加本地用户组织
    6. 试验不同环境 常用windows 那么试用下unix-like 系统，如果使用unix-like 那么就使用windows 试试
    7. 跟上潮流
    8. 上网查看新技术增加哪些内容
- 如果别人向你问问题，你没有思路，那么将这个问题作为自己的挑战，上网查书等查找到解决方案
- 记得甄别看到的或者听到的信息 -- 如何辨别获得的信息是不是正确的，必须要保证获得的信息都是正确的。 
### 交流
- 如何表达自己想要说的东西？ 规划想要说的东西，写出大纲，然后问自己是不是讲出了所想要表达的所有信息，提炼它知道确实是这样子为止。
- 如何了解听众？
    1. 你想要让他们学到什么？
    2. 他们对你讲的什么感兴趣？
    3. 他们多富有经验？
    4. 他们想要多少细节？
    5. 你想让谁拥有这些信息？
    6. 你如何促使他们听你的话？
- 如何选择时机？ 
- 让文档美观？ 如果文档不美观可能会导致别人否定你的努力。
- 让听众参与？ 获得用户的反馈，听取他们意见。
- 如何做倾听者？ 将会议变成对话。
- 说什么和怎么说同样重要 
- 电子邮箱的提示？ 
    1. 在你按下【发送】之前进行校对
    2. 检查拼写
    3. 让格式变成简单
    4. 在确定对方能阅读富文本之后采用，纯文本是通用的
    5. 设法让引文减至最少个，不要使用回邮
    6. 如果引用了别人的邮件，一定要注明出处
    7. 不用语言攻击别人。
    8. 在发送邮件之前确认收件人名单
    9. 将电子邮件--收到的重要的文件和你发送的邮件--加以组织存档。
## 注重时效的途径
### 重复的危害
- 重复有哪些危害？ 如果有两处或多处地方表达同一事物，如果你改变了其中一项，你必须记得改变其他各处。
- 不要对知识进行重复，不要把任何一项知识分散在多个系组件中，系统中的每一项知识都必须具有单一，无歧义，权威的表述
- 重复如何发生？
    1. 强加的重复 觉得重复别无选择，环境要求重复
    - 项目标准要求建立含有偿付信息的文档，或是重复代码中的信息文档，多个平台需要自己的编程语言、库及开发环境，这会让我们重复共有的定义或者过程。编程语言自身要求某种重复的结构。
    - 如何解决？ 信息的多种表示，在编码一级，我们常需要以不同的心事表示同一信息。
    - 如何使用代码生成器，根据公共元数据表示构建多种语言下的结构。可以根据在线数据库schema或最初用于构建schema的元数据，自动生成类定义。
    - 代码中的文档？ 首相首先需要说明一点，只有糟糕的代码才需要文档，注释是要保留给高级说明的，比如接口的功能，参数说明。
    - 文档与代码 ？ 如何根据文档本身生成测试，当修改文档规范的时候，测试套件会自动改变。
    - 语言问题出现的重复？ 许多的语言会在源码中添加可观的重读。没有什么简单的技术可以用于解决语言的要求（比如接口和实现会应用非同一个类，接口和实现的函数名对应，一个函数名出现了两次）
    - 绝对没有理由在两种文件之间重复函数或类头注释。应该用头文件记载接口问题（Java 中是接口文件） 用实现文件记载代码的使用者无需了解的实际细节。
    2. 无意的重复 没有意识到重复
        - 避免不规范的数据，观察以下代码
        ```c++
        class Line{
            public:
                Point start;
                Point end;
                double length;
        }
        ```

        咋一看没有什么问题，但是这里是有重复的，长度是有起点和终点决定的，改变其中一个，长度就会发生改变，最好让长度编程计算字段。查看修改后的代码：
        ```c++
        class Line{
            public :
            Point start;
            Point end;
            double length{
                return start.distaneTo(end);
            }
        }
        ```

        - DRY 原则在什么情况下是允许违反呢？ 在以后的开发过程中，可能会因为性能问题而选择放弃DRY原则，这常用与缓存数据，以避免重复计算。其诀窍是是影响局部化，DRY没有暴露给外界：只在勒种的方法需要注意“保持行为良好”，缓存后的代码：
        ```c++
        class Line{
            private:
                bool changed;
                double length;
                Point start;
                Point end;

            public:
            void setStart(Point p){
                start = p;
                changed = true;
            }
            void setEnd(Point p){
                end = p;
                changed = true;
            }

            Point getStart(){
                return start;
            }

            Point getEnd(){
                return end;
            }

            double getLength(){
                if(changed){
                    length = start.distanceTo(end);
                    changed = false;
                }
                return length;
            }
        } 
        ```
        这个例子还说明了面向对象语言的一个重要问题，在可能的情况下尽量使用访问器函数读写对象属性。这将为未来添加功能（比如缓存）变得容易。
        
    3. 无耐性的重复 想要偷懒，觉得重复比较简单
        - 无耐性的重复是什么造成的？ 无耐性的重复由开发者的懒惰造成的。
        - 无耐性的重复是什么？ 无耐性的重读是一种容易检测和处理的重复形式，但是那需要你接受训练，并愿意为避免以后的痛苦预先花一些时间。
    4. 开发者之间的重复，同一团队（不同团队）几个人重复了相同的信息
        - 开发者之间的重复是如何造成的？在模块层面，问题难以发现，不能划入某个明显的责任区域的常用功能和数据可能被实现多次。
        - 如何决绝开发者之间的重复问题？ 最佳方式是鼓励开发者相互交流。设置论坛用于交流问题。一定要阅读别人的代码和文档，不管是非正式还是代码复查，你不是在窥探--你是在向他们学习，而且要记住访问时互惠的--不要为别人专研你的代码而苦恼。所做的一切都是为了营造一种环境，在其中找到并复用已有代码，比自己编写更容易。如果不容易大家不回去复用。如果不进行复用，那么就会有重复知识的风险。
### 正交性
- 什么是正交性：某种不相互依赖性和解耦性，如果两个或者更多事物中一个发生变化，不会影响其他事物就是正交的，在设计良好的系统中，数据库代码和用户代码就是正交的，你可以改变界面而不影响数据库；更换数据库而不改动界面
- 正交的好处：设计自足，独立具有单一，良好定义的目的。如果组建是独立的你就能改变其中之一而不用担心改变其它组件，紫瑶不改变外部接口就可以放心，不会造成波及整个系统的问题。
- 两个主要的好处：
    - 提高生产率
        1. 改动得以局部化，所以开发时间得以降低
        2. 正交的途径可以促进复用
        3. 如果你对正交组件进行组合，生产率会有相当微妙的提高
    - 降低风险
        1. 正交的途径可以降低任何开发中固有的风险
        2. 有问题的代码被隔离开来。如果某个模块有毛病，它不会把病症扩散到系统中其余部分
        3. 所得系统更加健壮
        4. 正交系统很可能能得到更好的测试，因为设计测试，，并针对其组建运行测试更容易
        5. 你不会与特定的供应商、产品、或平台紧绑在一起，因为与第三方组建的接口将被隔离在全部开发的最小部分
- 团队的正交性：判断团队的正交性最直观的办法就是看改动一个涉及到了多少人。
    1. 如何实现团队的正交 ? 将团队划分责任得到良好定义的小组
- 设计正交系统：模块化、基于组建分层，理想的状态是改变一个特定的需求，只有一个模块收到影响。 设计的时候不要依赖无法控制的属性。

- 工具箱和库：引入库时，不迫使你对代码进行不必要的改动。如果要求你以一种特殊的方式创建或访问对象，那么他就不是正交的。
    1. 正交性的例子 AOP 

- 编码：
    1. 让代码保持解耦
    2. 避免使用全局数据
    3. 避免编写相似的函数
    养成不断批判自己代码的习惯，寻找任何重新组织以盖上其结构和正交性的机会。这个过程叫做重构
- 测试：正交设计和实现的系统也更易于测试，因为系统的各组件的交互是形式化的和有限的，更多的系统测试可以在单个的模块级进行。
    1. 修正bug也是一个检验正交性的好时候，如果使用了源码控制系统，那么签回时标记修复bug所影响的文件数就显示了正交性。
- 文档：坐标轴是内容和表现形式？对于真正正交的文档，可以改变外观而不改变内容。
- 认同正交性：正交性和DRY原则紧密相关。运用DRY原则，你是在寻求是系统中重复性降到最低，运用真叫原则，可以降低系统中各组件的依赖。如果你紧密结合DRY原则，运用正交原则，你会发现开发的系统会变得灵活，更易于理解，更易于调试，测试和维护。

### 可撤销性
- 不必做出许多关键的决，不可逆转的决策
- 把决策视为写在沙滩上的，而不要把它们刻在石头上，大浪过来随时会把它们抹去。
### 曳光弹
- 提示：用曳光弹找到目标。
- 曳光弹的优点：
    1. 用户能够即使看到工作东西
    2. 开发者构建出一个能在其中工作的结构
    3. 有了一个集成平台
    4. 有了可用于演示的东西
    5. 更能感觉工作进展
- 曳光弹并非总能击中目标，找出能够改变的东西，让他接近目标
- 曳光弹和原型制作的区别
    原型制作： 使用真正的原型，在对概念进行试验后。你会把捆扎在一起的无论什么东西都扔掉，并根据学到的经验教训重新适当的进行编码。
    曳光弹：曳光弹处理的是不同的问题。你们需要知道应用怎么结合成一个整体。你想要向用户演示，实际的交互是怎样工作的，同时你还想给出一个架构骨架，开发者可以在其上添加代码。
    可以把原型制作看作是曳光弹发射之前做的侦察工作。
### 原型与便笺
- 应该制作原型的事物：
    1. 架构
    2. 已有系统中的新功能
    3. 外部数据的结构或内容
    4. 第三方工具或组建
    5. 性能问题
    6. 用户界面设计
- 原型设计的目的？为了学习而制作原型
- 原型制作时可以忽略的细节？
    1. 正确性
    2. 完整性
    3. 健壮性
    4. 风格
- 架构原型的制作目的？寻求的时了解系统怎么结合为一个整体，并推迟考虑细节。
- 架构原型中寻求解答的具体问题?
    1. 主要组件的责任是不是得到了良好的定义？是否恰当？
    2. 主要组建之间的交互是否得到了良好的定义
    3. 耦合是否得以最小化
    4. 你能否确定重复的潜在来源
    5. 接口定义和各项约束是否可接受？
    6. 每个模块在执行过程中是否访问到其他数据？是否能在需要时进行访问？
- 如何不使用原型？ 如果原型代码的目的可能被误解，最好采用曳光弹方法
### 领域语言
- 什么时候使用领域语言？如果用户有一些做了良好限定的称述，你可以发明一种为应用领域进行恰当剪裁的小型语言，这种语言无需是可执行的。
- 领域语言的目的？ 用于捕捉用户的需求的一种方式，如果想要更进一步，实现该语言，你的规范将变成可执行代码。
- 提示：靠近问题领域进行编程。

### 估算
- 提示：估算以避免发生意外
- 多准确才是够准确？
    | 时长 | 报出估算的单位 |
    | --- |---|
    | 1-15 天| 天|
    | 3-8 周|周|
    | 8-30 周|月|
    | 30+ 周| 在给出估算前努力思考下|
- 估算的前提条件
    1. 建立对于提问内容的理解，在估算之前先思考范围
    2. 根据你对所提问题的理解，建立粗略、就绪的思维模型骨架。
    3. 建模把不精确性引入了估算过程中。这是不可避免的也是有益的，你是在用简单性和精确性做交易。
- 将模型分解为组建，并找出数学规则描述这些组建的交互，在这一阶段需要确定每个参数
- 给每个参数指定值
- 计算答案： 计算多次，改变关键参数的值，直到找出主导模型的值。
- 追踪估算能力
 如果估算错了找出，事实和估算有差异的原因，下一次就能做的更好。
- 实现增量开发、重复一下步骤：
    1. 检查需求
    2. 分析风险
    3. 设计、实现、集成
    4. 向用户确认
- 提示：通过代码对进度表进行迭代
- 被要求估算是说什么？ 我等会儿再回答你。
## 基本工具
- 为什么要学习这些工具？ 花时间学习工具有一天会发现，手指在键盘上移动而不用进行有意识的思考。工具成为了手的延伸。
### 纯文本威力
- 纯文本的定义？纯文本是由打印字符组成人可以直接阅读和理解的形式。
- 纯文本的结构？纯文本是有结构的XML，HTML 都是良好定义的纯文本的良好例子。可以通过纯文本做任何二进制能够做的事情。
- 纯文本的好处之一：你可以获得自描述的、不依赖与他的应用的数据流。
- 纯文本的缺点？
    1. 与压缩的二进制相比，纯文本需要的存储空间更大。
	2. 要解释及处理纯文本文件，计算上的代价更大。
- 纯文本的安全性?纯文本数据也许晦涩难懂但是绝非安全.
- 文本的威力
	1. 保证不过时
		- 人能阅读的数据形式，以及自描述的数据形式将比其他数据形式和创建它的应用程序活的更久。
		- 只需要部分了解它的数据格式就可以解析这样的文件，而二进制需要完整地了解它的数据格式才能解析文件。
	2. 杠杆作用
		- 实际上，计算世界中的每一样工具，从源码控制系统到编译器环境，再到编辑器及独立的过滤器，都能在纯文本上进行操作。
	3. 更易于测试
		- 如果你用纯文本创建用于启动系统测试的合成数据，那么增加、更新、或是修改测试数据就是一件容易的事情，而且无需为此创建特殊的工具
- 最小公分母
	- 即使在未来，基于XML的智能代理亦能够自治地穿越混乱、危险的Internet、自行协商交换，无处不在的纯文本也依然能存在。在异种环境中从，纯文本的优点比其所有的缺点都重要。

### shell游戏
- 对于文本文件操作的程序员shell就是工作台。
- 通过对shell进行编程，你可以构建复杂的宏命令，用来完成日常工作中经常进行的各种活动。 
### 强力编辑
- 提示：用好一种编辑器
- 好的编辑器应该具有的能力：
	1. 可配置：编辑器的所有喜好都应该能按你的偏好进行配置，只使用敲击的效率更高，因为手无需离开键盘。
	2. 可扩展性：编辑器不应该在只因为出现了新的编程语言就变得过时。它应该能继承你在是哦那个的任何编译环境。
	3. 可编程性：你应该能对编辑器编程，让他执行复杂的多步骤的任务。可以通过宏或内建的脚本编程工具进行这样的编程。
	4. 语法高亮
	5. 自动补全
	6. 初始代码和文档样板
	7. 与帮助系统挂接
	8. 类IDE特性
- 生产率： 有些有些编辑器能帮助你使用常用操作的流水线
	1. 填好的类名或者模块名
	2. 你的名字或者版权声明
	3. 该语言中的各种构造体的骨架
- 然后做什么：
	|如果这听起来像你......|那么考虑......|
	|---|---|
	|我使用很多不同的编辑器但是只使用其基本功能|选择一种强大的编辑器，好好学习使用它|
	|我有最喜爱的编辑器，但是不使用其全部特性|学习他们减少需要敲击的键数|
	|我有最喜欢的编辑器，只要有可能就使用它|设法拓展它，并将其用于比现在更多的任务|
	|我以为你们在胡说，notepad是有史以来最好用的编辑器|只要你愿意并且生产率够高，那就这样吧！但是如果你发现自己在“羡慕”别人的编辑器那么你可能需要重新考虑自己的位置|
- 编辑器的推荐：
	1. Emacs
	2. vim
### 源码控制
- 提示：总是使用源码控制
- 把整个项目置于源码系统控制的保护之下具有一项很大隐蔽的好处你可以进行自动的可重复的构建。
### 调试
- 提示：要修正问题而不是指责。
- 提示：记住调试的第一准则，不要恐慌
### 文本操作
- 文本操作语言对于编程的意义就像刨机对于木工活的意义。
- 好的文本操作语言
    1. shell 可以使用awk和sed这样的语言来增强
    2. Python具有良好的面向对象本质
    3. tcl
    4. perl 编写短小的脚本
- 提示：学习一种文本操作语言
- 使用文本操作语言进行数据库schema 的维护：
    - 用于创建数据库的SQL 语言
    - 用于填充数据词典的平板数据文件
    - 用于访问数据库的C代码库
    - 用于检查数据库完整性的脚本
    - 含有schema 描述即框图的网页
    - schema的xml版本
- Java属性访问。根据成员变量生成get和set方法
- 测试数据生成
### 代码生成器
- 提示：编写能编写代码的代码
- 代码生成器：
	1. 被动代码生成器只运行一次来生成结果，然后结果变成了独立的——他被代码生成器分离了，
	2. 主动代码生成器在每次需要其结果时被使用。结果是用过就扔的——它总是能由代码生成器重新生成。
- 被动代码生成器：
	1. 创建新的源文件
	2. 在编程语言之间进行一次性切换,它有一个有趣的特性：他们不必完全准确。你需要在你投入生成器和你花费在修正其输出上的精力之间做权衡。
	3. 生成查找表及其他在运行时计算很昂贵的资源。
- 主动代码生成器
	1. 数据库读取和生成实体结构
	2. 只有在你让代码生成构建过程中自身的一部分这个方案才能工作。
	3. 如何根据数据库schema构建代码，如果schema是存在平板文件中的，那么一个相对简单的脚本就可以解析它并生成源码如果直接在数据库中创建那么就可以从数据库中提取想要的信息。
## 注重时效的偏执
- 提示：你不可能写出完美的代码
- 以为以上的提示我们连自己都不相信，所有要对自己的错误进行防御性编程
### 按合约设计
- DBC 什么是正确的程序？ 不多不少，做它声明要做的事情的程序。
- 在开始做事情之前，例程对世界的状态有某种期许，并且有能力称述系统结束时的状态
	- 前条件：为了调用例程必须为正确的条件；例程的需求，在其前条件被违反时，例程绝不允许调用。传递好数据时调用者的责任。
	- 后条件：例程保证会做某件事情，例程完成时世界的状态，例程有后条件这一事实，意味着不可能无限循环
	- 类不变项：类确保从调用者的角度来看，该条件总是为真，在例程处理过程中，不变项不一定会保持，但是退出时肯定为真。
- 例程和任何潜在调用者之间的合约可以解读为：如果调用者满足所有例程的所有前置条件，例程应该保证在其完成时所有后条件和不变项为真。如果任何一方没有履行合约那么某种补偿措施就会启动比如抛出异常或中止程序。
- 提示：通过合约进行设计
- 对开始之前的要求要严格，而允诺返回的的东西要尽可能少。
- 子类必须要能通过基类的接口调用，而使用者无需知道其区别。
- 使用DBC最大的好处是它迫使需求和保证的问题走到前台来。
### 死程序不说谎
- 提示：早奔溃
### 断言式编程
- 提示:如果它不可能发生，那么用断言确保他不会发生。
- 让断言开着，关闭断言就像因为你曾经成功过，就不用保护网去走钢丝。那样做有极大的价值，但是去难以获得人身保险。
###  何时使用异常
- 将异常用于异常的问题
### 怎么配平资源
- 你分配资源、使用它，然后解除其分配
- 提示：要有始有终
- 将打开文件和关闭文件放在一起
- 以资源分配的顺序的相反顺序解除资源的分配
- 在代码中分配相同资源的时候，总是以相同的次序分配他们，他们降低发生死锁的可能性
- Java实现的是一种自动对象分配的懒惰形式，未被引用的对象被认为是垃圾收集的候选者
- 当try块中的任何代码被执行那么finally子句中的代码就会执行
## 弯曲，或折断

### 解耦与得墨忒耳法则
- ”羞怯“的工作方式有两种：不向别人暴露自己和不与太多人打交道
- 提示： 使耦合减至最少
- 函数的得墨忒耳法则
	1. 调用自身的方法
	2. 传入该方法的参数
	3. 创建的任何对象
	4. 任何直接持有的组建对象
- 遵循得墨忒尔法则缩小了调用类中响应集的规模，以这种方式设计的类错误也往往更少。
- 得墨忒耳会带来很多的包装方法是的性能受影响，我们需要对这进行折衷。

### 元程序设计
- 把细节赶出代码
- 提示：要配置不要集成
- 要用元数据描述应用的配置选项：调谐参数、用户偏好、安装目录等等。
- 将抽象放进代码，将细节放进元数据
	1. 它迫使你解除你设计的耦合,从而带来更灵活的，可适应性更好的程序
	2. 它迫使你推迟细节的处理，创建更加健壮，更抽象的设计，完全推迟到程序之外
	3. 无需重新编译应用，你可以对其进行定制。你可以利用这一层面的定制，轻松绕开正在运行中的程序的bug。
	4. 与通用语言的情况相比，可以通过一种大为接近问题领域的方法表示元数据
	5. 你甚至可以使用相同的应用引擎——单用不同的元数据——实现不同的项目
### 时间耦合
- 分析工作流，以改善并发性
- 对并发进行设计 
	1. 必须对任何全局或静态变量加以保护
	2. 不管调用的次序是什么状态必须是一致的
- 提示：总是为并发设计
### 它只是视图
- 发布/订阅 模式
	如果我们对于某个Publisher生成特定的事件感兴趣，我们所需要做的只是登记我们自己。Publisher追踪所有感兴趣的Subscriber对象；当Publisher生成有趣事件时，它就依次调用每个Subscriber，通知他们该事件已经发生。
- MVC
	使得模型与视图分离
	在典型的情况下MVC 是在GUI开发环境中教授的，它其实是一种通用的编程技术。视图是对模型的一种解释——它无需是图形化的。控制器更是一种协调机制，不一定与任何种类的输入设备有关。
	1. 模型 表示目标的抽象数据模型。模型对于任何视图和控制器都没有直接的了解。
	2. 视图 解释模型的方法。它们订阅模型中的变化和来自控件的逻辑事件。
	3. 控制器 控制视图并向模型提供新数据的途径。它既向模型、也向视图发布事件
### 黑板
## 当你编码时
### 靠巧合编程
- 提示：不要靠巧合编程
### 算法速率
### 重构
### 易于测试的代码
### 邪恶的向导
## 在项目开始之前
### 需求之坑
### 解开不可能解开的谜题
### 等你准备好
### 规范陷阱
### 圆圈与箭头
## 注重时效的项目
### 注重时效的团队
### 无处不在的自动化
### 无情的测试
### 全都是写
### 极大的期望
### 傲慢与偏见
